### 多线程

---

#### ！1、进程和线程的区别

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.
通俗一点说，进程就是程序的一次执行，而线程可以理解为进程中的执行的一段程序片段。

#### ！2、并行和并发的区别和联系

并发（concurrency）和并行（parallellism）区别：

* 解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
* 解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
* 解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群
> 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

并发（concurrency）和并行（parallellism）联系：
都是同时处理多路请求的意思.

#### ！3、同步与异步

同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)

>所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由**调用者**主动等待这个**调用**的结果。

> 而异步则是相反，**调用**在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在**调用**发出后，
**被调用者**通过状态、通知来通知调用者，或通过回调函数处理这个调用。

#### ！4、多线程的实现方式，有什么区别
继承Thread和实现Runable接口，最重要的一个区别是实现Runable接口避免Java的单继承特性带来的局限；

#### ！5、什么叫守护线程

> Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)

> 用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，
比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为没有如果没有了被守护这，也就没有继续运行程序的必要了。
如果有非守护线程仍然存活，VM就不会退出。

> 守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon（true）方法设置当前线程为守护线程。

> 虽然守护线程可能非常有用，但必须小心确保其他所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。
一旦所有的用户线程退出了，虚拟机也就退出运行了。 因此，不要在守护线程中执行业务逻辑操作（比如对数据的读写等）。

>另外有几点需要注意：

 * setDaemon(true)必须在调用线程的start（）方法之前设置，否则会跑出IllegalThreadStateException异常。
 * 在守护线程中产生的新线程也是守护线程。
 * 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。

#### %6、如何停止一个线程？

调用stop,interrupt，或者设置标志位，代码根据标志位退出线程。

#### ！7、什么是线程安全？
保证在多线程的环境下，数据不会被污染。
#### ！8、synchronized 和 lock的区别
synchronized不需要显示的释放锁，程序结束时会自动释放，lock需要手动调用unlock释放.
lock的在读写多的情况下性能更好，因为提供了读写锁，读读不互斥.
#### ！9、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
在锁没有释放之前，其他线程不可以进入此方法
#### ！10、启动一个线程是用run()还是start()?
start(),调用run方法相当于一个普通方法的调用，不会开启一个子线程。

#### ！12、wait和sleep的区别
* sleep是Thread类的方法, wait是Object类中定义的方法
* sleep 方法可能抛出一个InterruptedException,这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这个异常。
  因为java强制捕获必检的异常，所以，必须将他放到try-catch块中。如果在一个循环中调用了sleep方法，那就应该将这个循环放在
  try-catch 块中，如果循环在try-catch块外，即使线程被中断，它也可能会继续执行。而wait，notify和notifyAll不需要捕获异常。
* 监视器（monitor)是一个相互排斥且具备同步能力的对象。监视器中的一个时间点上，只能有一个线程执行一个方法。 线程通过获取监视器上的锁进入监视器，
  并且通过释放锁退出监视器。任意对象都可能是一个监视器。一旦一个线程锁住对象，该对象就成为监视器。 在执行同步方法或块之前，线程必须获取锁。
  Thread.sleep()和Object.wait()都会暂停当前的线程, sleep() 不会释放monitor ,调用wait()方法可以释放monitor, 调用wait后，需要别的线程执行notify/notifyAll
  来通知一个或所有的等待线程重新获取锁并且恢复执行。
* waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronized block中进行调用。如果在non-synchronized函数或
  non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生illegalMonitorStateException的异常

#### %13、notify和notifyAll的区别
> 锁池和等待池
* 锁池: 假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，
     由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权， 但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
* 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中 
> 然后再来说notify和notifyAll的区别 
1. 如果线程调用了对象的 wait()方法， 那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
2. 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，
锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，
3. 等待锁竞争优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法， 它才会重新回到等待池中。
而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。
> 综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池 notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，
如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。有了这些理论基础，后面的notify可能会导致死锁，而notifyAll则不会的例子也就好解释了


notifyAll使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。
notify则文明得多他只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，
当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由
于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll

#### %14、线程池的作用

减少频繁创建线程和切换，销毁带来的性能开销；
#### %15、Java中线程池相关的类

列举几个常用的线程池：
    1.newCachedThreadPool
    创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
    2.newFixedThreadPool
    创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待
    3.newScheduledThreadPool
    创建一个定长线程池，支持定时及周期性任务执行
    4.newSingleThreadExecutor
    创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
#### 参考资料

1. [java中的锁](http://www.importnew.com/19472.html)


>Contributes: hueizhe
>
>Reviewers : Hollis, Kevin Lee
